/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

#include "DSRhoPDFTIndep.h"
#include "Constants.h"

//ClassImp(DSRhoPDF)

DSRhoPDFTIndep::DSRhoPDFTIndep(const char *name, const char *title,
                   RooAbsReal& _tht,
                   RooAbsReal& _thb,
                   RooAbsReal& _phit,
                   RooAbsReal& _ap,
                   RooAbsReal& _apa,
                   RooAbsReal& _a0,
                   RooAbsReal& _ata) :
    RooAbsPdf(name,title),
    tht("tht","tht",this,_tht),
    thb("thb","thb",this,_thb),
    phit("phit","phit",this,_phit),
    ap("ap","ap",this,_ap),
    apa("apa","apa",this,_apa),
    a0("a0","a0",this,_a0),
    ata("ata","ata",this,_ata)
{

}


DSRhoPDFTIndep::DSRhoPDFTIndep(const DSRhoPDFTIndep& other, const char* name) :
    RooAbsPdf(other,name),
    tht("tht",this,other.tht),
    thb("thb",this,other.thb),
    phit("phit",this,other.phit),
    ap("ap",this,other.ap),
    apa("apa",this,other.apa),
    a0("a0",this,other.a0),
    ata("ata",this,other.ata)
{

}


Double_t DSRhoPDFTIndep::evaluate() const
{

    Double_t a0a = 0;
    Double_t at = sqrt(1-ap*ap-a0*a0);

    Double_t ap0r = ap*a0*cos(-apa+a0a);
    // Double_t ap0i = ap*a0*sin(-apa+a0a);
    // Double_t a0tr = a0*at*cos(-a0a+ata);
    Double_t a0ti = a0*at*sin(-a0a+ata);
    // Double_t aptr = ap*at*cos(-apa+ata);
    Double_t apti = ap*at*sin(-apa+ata);

    Double_t value = ap*ap*2*sin(tht)*sin(tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)*sin(phit)*sin(phit)+\
                                at*at*2*cos(tht)*cos(tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)+\
                                a0*a0*4*sin(tht)*sin(tht)*sin(tht)*cos(thb)*cos(thb)*sin(thb)*cos(phit)*cos(phit)+\
                                sqrt(2)*ap0r*sin(tht)*sin(tht)*sin(tht)*sin(2*thb)*sin(thb)*sin(2*phit)-\
                                sqrt(2)*a0ti*sin(2*tht)*sin(tht)*sin(2*thb)*sin(thb)*cos(phit)-\
                                2*apti*sin(2*tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)*sin(phit);

    return value ;
}



Int_t DSRhoPDFTIndep::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
    // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
    // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
    // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
    // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
    // EXPRESSION MULTIPLE TIMES

    // if (matchArgs(allVars,analVars,x)) return 1 ;

    if(matchArgs(allVars,analVars,tht,thb,phit)) return 1;
    if(matchArgs(allVars,analVars,tht,thb)) return 2;
    if(matchArgs(allVars,analVars,tht,phit)) return 3;
    if(matchArgs(allVars,analVars,thb,phit)) return 4;
    if(matchArgs(allVars,analVars,tht)) return 5;
    if(matchArgs(allVars,analVars,thb)) return 6;
    if(matchArgs(allVars,analVars,phit)) return 7;

    return 0 ;
}



Double_t DSRhoPDFTIndep::analyticalIntegral(Int_t code, const char* rangeName) const
{
    // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
    // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
    // BOUNDARIES FOR EACH OBSERVABLE x

    // assert(code==1) ;
    // return (x.max(rangeName)-x.min(rangeName)) ;

    Double_t a0a = 0;
    Double_t at = sqrt(1-ap*ap-a0*a0);

    Double_t ap0r = ap*a0*cos(-apa+a0a);
    // Double_t ap0i = ap*a0*sin(-apa+a0a);
//    Double_t a0tr = a0*at*cos(-a0a+ata);
//    Double_t a0ti = a0*at*sin(-a0a+ata);
    // Double_t aptr = ap*at*cos(-apa+ata);
    Double_t apti = ap*at*sin(-apa+ata);


    switch(code)
    {
    case 1: // Int[g,{tht,thb,phit}]
        return 32.*PI/9;

    case 2: // Int[g,{tht,thb}]
        return 16./9.*(at*at + 2*a0*a0*cos(phit)*cos(phit) + 2*ap*ap*sin(phit)*sin(phit));

    case 3: // Int[g,{tht,phit}]
        return 8.*PI/3*((ap*ap+at*at)*sin(thb)*sin(thb) + 2*a0*a0*cos(thb)*cos(thb))*sin(thb);

    case 4: // Int[g,{thb,phit}]
        return 8.*PI/3*((ap*ap+a0*a0)*sin(tht)*sin(tht) + 2*at*at*cos(tht)*cos(tht))*sin(tht);

    case 5: // Int[g,{tht}]
        return 4./3.*(4*a0*a0*cos(phit)*cos(phit)*cos(thb)*cos(thb) + \
       (at*at + 2*ap*ap*sin(phit)*sin(phit))*sin(thb)*sin(thb) + sqrt(2)*ap0r*sin(2*phit)*sin(2*thb))*sin(thb);

    case 6: // Int[g,{thb}]
        return 8./3.*(at*at*cos(tht)*cos(tht) + a0*a0*cos(phit)*cos(phit)*sin(tht)*sin(tht) + \
       sin(phit)*(ap*ap*sin(phit)*sin(tht)*sin(tht) - apti*sin(2*tht)))*sin(tht);

    case 7: // Int[g,{phit}]
        return 2*PI*(2*at*at*cos(tht)*cos(tht)*sin(thb)*sin(thb) +
       (2*a0*a0*cos(thb)*cos(thb) + ap*ap*sin(thb)*sin(thb))*sin(tht)*sin(tht))*(sin(tht)*sin(thb));

    default:
        return 0;
    }

}

