/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

#include "DSRhoPDF.h"
#include "Constants.h"

//ClassImp(DSRhoPDF)

DSRhoPDF::DSRhoPDF(const char *name, const char *title, const char *_type,
                   RooAbsReal& _tht,
                   RooAbsReal& _thb,
                   RooAbsReal& _phit,
                   RooAbsReal& _dt,
                   RooAbsReal& _ap,
                   RooAbsReal& _apa,
                   RooAbsReal& _a0,
                   RooAbsReal& _ata,
                   RooAbsReal& _xp,
                   RooAbsReal& _x0,
                   RooAbsReal& _xt,
                   RooAbsReal& _yp,
                   RooAbsReal& _y0,
                   RooAbsReal& _yt) :
    RooAbsPdf(name,title),
    tht("tht","tht",this,_tht),
    thb("thb","thb",this,_thb),
    phit("phit","phit",this,_phit),
    dt("dt","dt",this,_dt),
    ap("ap","ap",this,_ap),
    apa("apa","apa",this,_apa),
    a0("a0","a0",this,_a0),
    ata("ata","ata",this,_ata),
    xp("xp","xp",this,_xp),
    x0("x0","x0",this,_x0),
    xt("xt","xt",this,_xt),
    yp("yp","yp",this,_yp),
    y0("y0","y0",this,_y0),
    yt("yt","yt",this,_yt)
{
    if     (strcmp(_type,"a") == 0)
        type = 1;
    else if(strcmp(_type,"ab") == 0)
        type = 2;
    else if(strcmp(_type,"b") == 0)
        type = 3;
    else if(strcmp(_type,"bb") == 0)
        type = 4;
    else
        printf("ERROR: unknown _type: %s\n",_type);

}


DSRhoPDF::DSRhoPDF(const DSRhoPDF& other, const char* name) :
    RooAbsPdf(other,name),
    tht("tht",this,other.tht),
    thb("thb",this,other.thb),
    phit("phit",this,other.phit),
    dt("dt",this,other.dt),
    ap("ap",this,other.ap),
    apa("apa",this,other.apa),
    a0("a0",this,other.a0),
    ata("ata",this,other.ata),
    xp("xp",this,other.xp),
    x0("x0",this,other.x0),
    xt("xt",this,other.xt),
    yp("yp",this,other.yp),
    y0("y0",this,other.y0),
    yt("yt",this,other.yt)
{
    type = other.type;
}



Double_t DSRhoPDF::evaluate() const
{
    Int_t trig_sign = 1;

    Double_t a0a = 0;
    Double_t at = sqrt(1-ap*ap-a0*a0);

    Double_t ap0r = ap*a0*cos(-apa+a0a);
    Double_t ap0i = ap*a0*sin(-apa+a0a);
    Double_t a0tr = a0*at*cos(-a0a+ata);
    Double_t a0ti = a0*at*sin(-a0a+ata);
    Double_t aptr = ap*at*cos(-apa+ata);
    Double_t apti = ap*at*sin(-apa+ata);

    Double_t At2 = 0;
    Double_t Ap2 = 0;
    Double_t A02 = 0;
    Double_t Ap0r = 0;
    Double_t A0ti = 0;
    Double_t Apti = 0;

    if(type < 1 || type > 4)
    {
        printf("ERROR: undefined type: %i",type);
        return 0;
    }

    /// Writing this again explicitly with the changed sign of sin(Bfreq*dt) and cos(Bfreq*dt) is safer than changing
    /// Bfreq or dt to exploit sin(Bfreq*dt + PI) = -sin(Bfreq*dt) because of numerical problems that can cause.
    if(type == 3 || type == 4)
        trig_sign = -1;

    Ap2 = ap*ap*((1 + xp*xp + yp*yp) + (1 - xp*xp - yp*yp)*trig_sign*cos(Bfreq*dt) + 2*yp*trig_sign*sin(Bfreq*dt));
    A02 = a0*a0*((1 + x0*x0 + y0*y0) + (1 - x0*x0 - y0*y0)*trig_sign*cos(Bfreq*dt) + 2*y0*trig_sign*sin(Bfreq*dt));
    At2 = at*at*((1 + xt*xt + yt*yt) + (1 - xt*xt - yt*yt)*trig_sign*cos(Bfreq*dt) - 2*yt*trig_sign*sin(Bfreq*dt));

    Ap0r = ap0r*((1 + xp*x0 + yp*y0) + (1 - xp*x0 - yp*y0)*trig_sign*cos(Bfreq*dt) + (yp + y0)*trig_sign*sin(Bfreq*dt)) -\
           ap0i*((xp*y0 - x0*yp)*(1 - trig_sign*cos(Bfreq*dt)) + (xp - x0)*trig_sign*sin(Bfreq*dt));

    A0ti = a0ti*((1 - x0*xt - y0*yt) + (1 + x0*xt + y0*yt)*trig_sign*cos(Bfreq*dt) + (y0 - yt)*trig_sign*sin(Bfreq*dt)) +\
           a0tr*((- x0*yt + xt*y0)*(1 - trig_sign*cos(Bfreq*dt)) + (x0 + xt)*trig_sign*sin(Bfreq*dt));

    Apti = apti*((1 - xp*xt - yp*yt) + (1 + xp*xt + yp*yt)*trig_sign*cos(Bfreq*dt) + (yp - yt)*trig_sign*sin(Bfreq*dt)) +\
           aptr*((- xp*yt + xt*yp)*(1 - trig_sign*cos(Bfreq*dt)) + (xp + xt)*trig_sign*sin(Bfreq*dt));



    Double_t value =    exp(-Bgamma*fabs(dt))*(Ap2*2*sin(tht)*sin(tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)*sin(phit)*sin(phit)+\
                        At2*2*cos(tht)*cos(tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)+\
                        A02*4*sin(tht)*sin(tht)*sin(tht)*cos(thb)*cos(thb)*sin(thb)*cos(phit)*cos(phit)+\
                        sqrt(2)*Ap0r*sin(tht)*sin(tht)*sin(tht)*sin(2*thb)*sin(thb)*sin(2*phit)-\
                        sqrt(2)*A0ti*sin(2*tht)*sin(tht)*sin(2*thb)*sin(thb)*cos(phit)-\
                        2*Apti*sin(2*tht)*sin(tht)*sin(thb)*sin(thb)*sin(thb)*sin(phit));

    //if(trig_sign == 1) return value;
//    printf("IN EVAL\n");
//    printf("PARS0: trig_sign = %i, Bfreq = %f, dt = %f\n",trig_sign,(double)Bfreq,(double)dt);
//    printf("PARS: ap0r = %f, ap0i = %f, a0tr = %f, a0ti = %f, aptr = %f, apti = %f\n",ap0r,ap0i,a0tr,a0ti,aptr,apti);
//    printf("PARS2: xp = %f, x0 = %f, xt = %f, yp = %f, y0 = %f, yt = %f\n",(double)xp,(double)x0,(double)xt,(double)yp,(double)y0,(double)yt);
//    printf("PARS3: Ap2 = %f, A02 = %f, At2 = %f, Ap0r = %f, A0ti = %f, Apti = %f\n",Ap2,A02,At2,Ap0r,A0ti,Apti);
//    printf("VALUE = %f\n", value);

    return value ;
}



Int_t DSRhoPDF::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
    // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED,
    // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS
    // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
    // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs
    // EXPRESSION MULTIPLE TIMES

    // if (matchArgs(allVars,analVars,x)) return 1 ;

    if(matchArgs(allVars,analVars,tht,thb,phit,dt)) return 1;
    if(matchArgs(allVars,analVars,tht,thb,phit)) return 2;
    if(matchArgs(allVars,analVars,tht,thb)) return 3;
    if(matchArgs(allVars,analVars,tht,phit)) return 4;
    if(matchArgs(allVars,analVars,thb,phit)) return 5;
    if(matchArgs(allVars,analVars,tht)) return 6;
    if(matchArgs(allVars,analVars,thb)) return 7;
    if(matchArgs(allVars,analVars,phit)) return 8;

    return 0 ;
}



Double_t DSRhoPDF::analyticalIntegral(Int_t code, const char* rangeName) const
{
    // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
    // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
    // BOUNDARIES FOR EACH OBSERVABLE x

    // assert(code==1) ;
    // return (x.max(rangeName)-x.min(rangeName)) ;

    Int_t trig_sign = 1;

    Double_t a0a = 0;
    Double_t at = sqrt(1-ap*ap-a0*a0);

    Double_t ap0r = ap*a0*cos(-apa+a0a);
    Double_t ap0i = ap*a0*sin(-apa+a0a);
//    Double_t a0tr = a0*at*cos(-a0a+ata);
//    Double_t a0ti = a0*at*sin(-a0a+ata);
    Double_t aptr = ap*at*cos(-apa+ata);
    Double_t apti = ap*at*sin(-apa+ata);

    Double_t At2 = 0;
    Double_t Ap2 = 0;
    Double_t A02 = 0;
    Double_t Ap0r = 0;
    Double_t Apti = 0;

    if(type < 1 || type > 4)
    {
        printf("ERROR: undefined type: %i",type);
        return 0;
    }

    /// Writing this again explicitly with the changed sign of sin(Bfreq*dt) and cos(Bfreq*dt) is safer than changing
    /// Bfreq or dt to exploit sin(Bfreq*dt + PI) = -sin(Bfreq*dt) because of numerical problems that can cause.
    if(type == 3 || type == 4)
        trig_sign = -1;

    Ap2 = ap*ap*((1 + xp*xp + yp*yp) + (1 - xp*xp - yp*yp)*trig_sign*cos(Bfreq*dt) + 2*yp*trig_sign*sin(Bfreq*dt));
    A02 = a0*a0*((1 + x0*x0 + y0*y0) + (1 - x0*x0 - y0*y0)*trig_sign*cos(Bfreq*dt) + 2*y0*trig_sign*sin(Bfreq*dt));
    At2 = at*at*((1 + xt*xt + yt*yt) + (1 - xt*xt - yt*yt)*trig_sign*cos(Bfreq*dt) - 2*yt*trig_sign*sin(Bfreq*dt));

    Ap0r = ap0r*((1 + xp*x0 + yp*y0) + (1 - xp*x0 - yp*y0)*trig_sign*cos(Bfreq*dt) + (yp + y0)*trig_sign*sin(Bfreq*dt)) -\
           ap0i*((xp*y0 - x0*yp)*(1 - trig_sign*cos(Bfreq*dt)) + (xp - x0)*trig_sign*sin(Bfreq*dt));

    Apti = apti*((1 - xp*xt - yp*yt) + (1 + xp*xt + yp*yt)*trig_sign*cos(Bfreq*dt) + (yp - yt)*trig_sign*sin(Bfreq*dt)) +\
           aptr*((- xp*yt + xt*yp)*(1 - trig_sign*cos(Bfreq*dt)) + (xp + xt)*trig_sign*sin(Bfreq*dt));


    switch(code)
    {
    case 1: // Int[g,{tht,thb,phit,dt}]
        if(type == 1 || type == 2)
            return 128.*PI/9.*(1/Bgamma+Bgamma/(Bfreq*Bfreq+Bgamma*Bgamma)+\
                    (ap*ap*(xp*xp+yp*yp)+a0*a0*(x0*x0+y0*y0)+at*at*(xt*xt+yt*yt))*(1/Bgamma-Bgamma/(Bfreq*Bfreq+Bgamma*Bgamma)));
        else
            return 128.*PI/9.*(1/Bgamma-Bgamma/(Bfreq*Bfreq+Bgamma*Bgamma)+\
                    (ap*ap*(xp*xp+yp*yp)+a0*a0*(x0*x0+y0*y0)+at*at*(xt*xt+yt*yt))*(1/Bgamma+Bgamma/(Bfreq*Bfreq+Bgamma*Bgamma)));

    case 2: // Int[g,{tht,thb,phit}]
        return 64.*PI/9.*exp(-Bgamma*TMath::Abs(dt))*(Ap2+At2+A02);

    case 3: // Int[g,{tht,thb}]
        return 32./9.*exp(-Bgamma*TMath::Abs(dt))*(At2 + 2*A02*cos(phit)*cos(phit) + 2*Ap2*sin(phit)*sin(phit));

    case 4: // Int[g,{tht,phit}]
        return 16.*PI/3.*exp(-Bgamma*TMath::Abs(dt))*(2*A02*cos(thb)*cos(thb) + (Ap2 + At2)*sin(thb)*sin(thb))*sin(thb);

    case 5: // Int[g,{thb,phit}]
        return 16.*PI/3.*exp(-Bgamma*TMath::Abs(dt))*(2*At2*cos(tht)*cos(tht) + (A02 + Ap2)*sin(tht)*sin(tht))*sin(tht);

    case 6: // Int[g,{tht}]
        return 8./3.*exp(-Bgamma*TMath::Abs(dt))*(4*A02*cos(phit)*cos(phit)*cos(thb)*cos(thb) + \
       (At2 + 2*Ap2*sin(phit)*sin(phit))*sin(thb)*sin(thb) + sqrt(2)*Ap0r*sin(2*phit)*sin(2*thb))*sin(thb);

    case 7: // Int[g,{thb}]
        return 16./3.*exp(-Bgamma*TMath::Abs(dt))*(At2*cos(tht)*cos(tht) + A02*cos(phit)*cos(phit)*sin(tht)*sin(tht) + \
       sin(phit)*(Ap2*sin(phit)*sin(tht)*sin(tht) - Apti*sin(2*tht)))*sin(tht);

    case 8: // Int[g,{phit}]
        return 4*PI*exp(-Bgamma*TMath::Abs(dt))*(2*At2*cos(tht)*cos(tht)*sin(thb)*sin(thb) +
       (2*A02*cos(thb)*cos(thb) + Ap2*sin(thb)*sin(thb))*sin(tht)*sin(tht))*(sin(tht)*sin(thb));

    default:
        return 0;
    }

}

